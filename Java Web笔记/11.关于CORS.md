# CORS（跨源资源共享）问题笔记

## 1. **什么是 CORS？**

**CORS (Cross-Origin Resource Sharing)** 是一种浏览器机制，用来控制一个站点的资源是否允许被不同源（domain、protocol、port）下的网页访问。CORS 主要是为了防止恶意网站访问其他网站的资源，以保障用户的数据安全。

## 2. **CORS 和浏览器的同源策略（Same-Origin Policy）**

- **同源策略**：浏览器为了防止恶意网站执行跨站请求，会限制脚本只能访问同源（协议、域名、端口都相同）的资源。
    
- **跨域请求**：当请求来自不同的源时（例如前端在 `localhost:5501`，后端在 `localhost:8080`），浏览器会执行 **CORS 策略** 来确保安全。
    

## 3. **CORS 预检请求（Preflight Request）**

在某些情况下，浏览器会先发送一个 **`OPTIONS` 请求** 来询问服务器是否允许进行跨域操作。服务器需要返回正确的 CORS 响应头，浏览器才会发送实际的跨域请求。

### 预检请求常见的头部：

- **`Access-Control-Allow-Origin`**：指定允许哪些源（origin）访问资源。
    
- **`Access-Control-Allow-Methods`**：指定允许的 HTTP 方法（如 `GET`、`POST`、`PUT` 等）。
    
- **`Access-Control-Allow-Headers`**：指定允许的请求头（如 `Authorization`、`Content-Type` 等）。
    
- **`Access-Control-Allow-Credentials`**：是否允许发送凭证（如 Cookies 或 HTTP 认证信息）。
    

## 4. **CORS 错误及常见问题**

- **跨域请求被阻止**：浏览器因为未能接收到正确的 CORS 头部，阻止了请求。
    
- **CORS 预检请求失败**：浏览器发起的 `OPTIONS` 请求未能成功响应，导致实际请求无法发送。
    
- **浏览器和 Postman 的差异**：Postman 不会受 CORS 限制的影响，能直接发送跨域请求，而浏览器会严格执行 CORS 策略。
    

## 5. **CORS 问题调试步骤**

1. **确认请求是否跨域**：
    
    - 即使前端和后端在同一台机器上，不同的端口（如 `localhost:5501` 和 `localhost:8080`）会被认为是 **不同的源**。
        
    - 浏览器认为它们是不同的源，因此会触发 CORS 策略。
        
2. **确保后端配置了正确的 CORS 头部**：

    - 使用 `@CrossOrigin` 或 `WebMvcConfigurer` 配置 CORS，允许特定来源的请求：
		```java
		    //全局CORS配置
		    @Bean
		    public WebMvcConfigurer corsConfigurer() {
		        return new WebMvcConfigurer() {
		            @Override
		            public void addCorsMappings(CorsRegistry registry) {
		                registry.addMapping("/**")
		                        .allowedOrigins("http://127.0.0.1:5501", "http://localhost:5501")
		                        .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
		                        .allowCredentials(true)
		                        .allowedHeaders("Authorization", "Content-Type")
		                        .maxAge(3600);  // 缓存预检请求的有效时间
		            }
		        };
		    }
		```
		
3. **前端发送请求时需要设置 `Authorization` 头部**：
    
    - 确保前端代码中正确地设置了 `Authorization` 头部，并且发送了有效的 JWT token 或其他认证信息：
        
```JS
    fetch(`http://localhost:8080/word/list?pageNum=${pageNum}`) {     
    method: 'GET',     
    headers: {         
		    'Authorization': `Bearer ${token}`,        
		    'Content-Type': 'application/json',     
		} 
	});
```
    
4. **前端处理无 `Authorization` 时的提示**：
    
    - 如果没有 `Authorization` token，前端应该提醒用户登录：
```JS
    if (!token) {     
	    alert("请先登录！");     
	    window.location.href = 'login.html';  // 未登录跳转到登录页面     
	    return ;
    }
```
    
5. **浏览器开发者工具的调试**：
    
    - 使用浏览器开发者工具（F12）查看 **Network** 面板，确认请求的 **请求头** 和 **响应头** 是否包含正确的 CORS 头部。
        
    - 检查 **`OPTIONS` 请求** 是否返回了 `200 OK`，并且响应头中包含了 `Access-Control-Allow-Origin` 等正确的 CORS 配置。
        

## 6. **处理 `OPTIONS` 请求的解决方法**

在解决 **CORS** 问题时，特别是 **`OPTIONS` 预检请求**，需要确保服务器返回了正确的响应。在 `UserStatusInterceptor` 中添加以下代码来处理 **`OPTIONS` 请求**：

```java
// 处理预检请求 
if ("OPTIONS".equals(request.getMethod())) { 
    response.setStatus(HttpServletResponse.SC_OK);  // 返回 200 OK     
    return false;  // 不再继续处理，直接返回成功 
}
```
`

- **为什么需要处理 `OPTIONS` 请求？**
    
    - `OPTIONS` 请求是浏览器发送的预检请求，目的是检查服务器是否允许跨域操作。如果不正确处理，浏览器会拒绝实际请求。
        
    - 通过在 `UserStatusInterceptor` 中判断并处理 `OPTIONS` 请求，确保浏览器能够顺利发起实际的跨域请求。


## 8. **调试和排查工具**

- **Postman**：Postman 不会遇到 CORS 限制，适合用于测试 API 的功能，但在实际部署时不能绕过 CORS，浏览器会执行严格的 CORS 检查。
    
- **浏览器开发者工具**：通过 **Network** 面板查看跨域请求的详细信息，检查是否正确响应 `OPTIONS` 请求并包含必要的 CORS 头部。
    

## 9. **总结**

- **CORS 策略** 是浏览器用来保护用户免受恶意请求的关键机制。
    
- 后端需要配置正确的 **CORS 头部**，尤其是 `OPTIONS` 预检请求，确保浏览器允许跨域请求。
    
- 前端需要正确设置 **Authorization** 和其他请求头，并确保请求携带认证信息。
    
- 使用浏览器开发者工具查看请求和响应，确保 CORS 配置无误。