# 一、项目介绍
## 1）简介
功能：
1. 登录功能
2. 对新闻话题的增删改查
3. 对新闻文章的增删改查
4. 修改头像、邮箱
5. 修改密码
## 2）技术栈组成
前端部分：vite、router、pina、element-plus
后端部分：Validation、Mybatis、Redis、Junit、项目部署
# 二、环境准备
**第一步：** 创建一个Maven工程
**第二步：** 在pom.xml中加入下列依赖
```xml
<!--    web依赖     -->  
    <dependency>  
      <groupId>org.springframework.boot</groupId>  
      <artifactId>spring-boot-starter-web</artifactId>  
    </dependency>  
<!--    mybatis依赖    -->  
    <dependency>  
      <groupId>org.mybatis.spring.boot</groupId>  
      <artifactId>mybatis-spring-boot-starter</artifactId>  
      <version>3.0.4</version>  
    </dependency>  
<!--    mysql驱动依赖   -->  
    <dependency>  
      <groupId>com.mysql</groupId>  
      <artifactId>mysql-connector-j</artifactId>  
      <version>9.1.0</version>  
    </dependency>
```
**第三步：** 配入mysql数据库的配置信息
```yml
spring:  
  datasource:  
    driver-class-name: com.mysql.cj.jdbc.Driver  
    url: jdbc:mysql://localhost:3306/big_event  
    username: root  
    password: 1234
```
**第四步：** 导入实体类
Article类：
```java
package com.itheima.pojo;  
  
import java.time.LocalDateTime;  
  
public class Article {  
    private Integer id;//主键ID  
    private String title;//文章标题  
    private String content;//文章内容  
    private String coverImg;//封面图像  
    private String state;//发布状态 已发布|草稿  
    private Integer categoryId;//文章分类id  
    private Integer createUser;//创建人ID  
    private LocalDateTime createTime;//创建时间  
    private LocalDateTime updateTime;//更新时间  
}
```

Category类：
```java
package com.itheima.pojo;  
  
import java.time.LocalDateTime;  
  
public class Article {  
    private Integer id;//主键ID  
    private String title;//文章标题  
    private String content;//文章内容  
    private String coverImg;//封面图像  
    private String state;//发布状态 已发布|草稿  
    private Integer categoryId;//文章分类id  
    private Integer createUser;//创建人ID  
    private LocalDateTime createTime;//创建时间  
    private LocalDateTime updateTime;//更新时间  
}
```

User类：
```java
package com.itheima.pojo;  

import java.time.LocalDateTime;  
  
public class User {  
    private Integer id;//主键ID  
    private String username;//用户名  
    private String password;//密码  
    private String nickname;//昵称  
    private String email;//邮箱  
    private String userPic;//用户头像地址  
    private LocalDateTime createTime;//创建时间  
    private LocalDateTime updateTime;//更新时间  
}
```

**第五步：** 将main里的App类改名为BigEventApplication，然后将主函数如下修改：
```java
package com.itheima;  
  
import org.springframework.boot.SpringApplication;  
import org.springframework.boot.autoconfigure.SpringBootApplication;  
  
@SpringBootApplication  
public class BigEventApplication {  
    public static void main(String[] args) {  
        SpringApplication.run(BigEventApplication.class, args);  
    }  
}
```
自此，后端环境搭建完毕。
# 三、用户相关功能
## 1）注册
### （1）开发过程
1. 明确需求
2. 阅读接口文档
3. 思路分析
4. 开发
5. 测试
详情见[github的Demo](https://github.com/inabananami/)
### （2）参数校验
将UserController加入：
```java
if (username != null && username.length() >= 5 && username.length() <= 16 &&  
        password != null && password.length() >= 5 && password.length() <= 16) {
```

输入用户名为w，密码为123456时，postman返回：
```json
{
    "code": 1,
    "message": "参数不合法",
    "data": null
}
```

为了简化代码，我们可以使用Spring Validation对注册接口的参数进行合法性校验。
1. 引入Spring Validation起步依赖
2. 在参数前面添加@Pattern注解
3. 在Controller类上添加@Validated注解
pom.xml添加：
```xml
<!--      Spring Validation    -->  
      <dependency>  
          <groupId>org.springframework.boot</groupId>  
          <artifactId>spring-boot-starter-validation</artifactId>  
      </dependency>
```

然后修改Controller类：
```java
public Result register(@Pattern(regexp = "^\\S{5,16}$") String username,@Pattern(regexp = "^\\S{5,16}$") String password)
```

最后处理参数校验失败的情况：
```java
package com.itheima.exception;  
  
import com.itheima.pojo.Result;  
import org.springframework.util.StringUtils;  
import org.springframework.web.bind.annotation.ExceptionHandler;  
import org.springframework.web.bind.annotation.RestControllerAdvice;  
  
@RestControllerAdvice  
public class GlobalExceptionHandler {  
  
    @ExceptionHandler(Exception.class)  
    public Result handleException(Exception e) {  
        e.printStackTrace();  
        return Result.error(StringUtils.hasLength(e.getMessage())? e.getMessage(): "操作失败");  
    }  
}
```
## 2）登录
### （1）主逻辑
UserController添加功能：
```java
@PostMapping("/login")  
public Result<String> login(@Pattern(regexp = "^\\S{5,16}$") String username, @Pattern(regexp = "^\\S{5,16}$") String password) {  
    //根据用户名查询User  
    User loginUser = UserService.findByUserName(username);  
    //判断是否查询到  
    if(loginUser == null) {  
        return Result.error("用户名错误");  
    }else{  
        //判断密码是否正确 loginUser对象中的password是密文  
        if(Md5Util.getMD5String(password).equals(loginUser.getPassword())) {  
            //登录成功  
            return Result.success("jwt token令牌...");  
        }  
        return Result.error("密码错误！");  
    }  
}
```
测试成功。
### （2）JWT
**简介：**
- 全称：JSON Web Token（https://jwt.io/）
- 定义了一种简洁的、自包含的格式，用于通信双方以json数据格式安全的传输信息。
- 组成：
	- 第一部分：Header（头），记录令牌类型，签名算法等。例如：`{"alg": "HS256", "type": "JWT"}`
	- 第二部分：Payload（有效载荷），携带一些自定义信息、默认信息等。例如：`{"id": "1", "username":"Tom"}
	- 第三部分：Signatrue（签名），防止Token被篡改、确保安全性。将header、payload，并加入指定密钥，通过指定签名算法计算而来。
先加依赖：
```xml
<!--      java-jwt坐标      -->  
      <dependency>  
          <groupId>com.auth0</groupId>  
          <artifactId>java-jwt</artifactId>  
          <version>4.4.0</version>  
      </dependency>  
  
<!--      单元测试的坐标    -->  
      <dependency>  
          <groupId>org.springframework.boot</groupId>  
          <artifactId>spring-boot-starter-test</artifactId>  
      </dependency>
```
#### ア、JWT-生成
测试类如下：
```java
package com.itheima;  

import com.auth0.jwt.JWT;  
import com.auth0.jwt.algorithms.Algorithm;  
import org.junit.jupiter.api.Test;  
import java.util.Date;  
import java.util.HashMap;  
import java.util.Map;  
  
public class JwtTest {  
  
    @Test  
    public void testGen() {  
        Map<String, Object> claims = new HashMap<>();  
        claims.put("id", "1");  
        claims.put("username", "张三");  
        //生成jwt的代码  
        String token = JWT.create()  
                .withClaim("user", claims)   //添加载荷  
                .withExpiresAt(new Date(System.currentTimeMillis()+1000*60*60*12))      //添加过期时间  
                .sign(Algorithm.HMAC256("uehara_ayumu"));  
  
        System.out.println(token);  
    }  
}
```
#### イ、JWT-验证
测试类如下：
```java
    @Test  
    public void testParse() {  
        //定义字符串，模拟用户传递过来的Token  
        String token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9" +  
                                ".eyJ1c2VyIjp7ImlkIjoiMSIsInVzZXJuYW1lIjoi5byg5LiJIn0sImV4cCI6MTc1MzEyNjU1Nn0" +  
                                ".-gvF0ZBLiXRi7YSQxeXJUFwwMZX-ESzjl_J8EYqmzww";  
        JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256("uehara_ayumu")).build();  
  
        DecodedJWT decodedJWT = jwtVerifier.verify(token);  //验证token，生成一个解析后的JWT对象  
        Map<String, Claim> claims = decodedJWT.getClaims();  
        System.out.println(claims.get("user"));  
		//如果篡改了头部和载荷部分的数据，那么验证失败  
		//如果密钥改了，验证失败
    }  
}
```
### （3）登录验证
在现在的项目中，倘若我们已经构建了ArticleController：
```java
package com.itheima.controller;  
  
import com.itheima.pojo.Result;  
import org.springframework.web.bind.annotation.GetMapping;  
import org.springframework.web.bind.annotation.RequestMapping;  
import org.springframework.web.bind.annotation.RestController;  
  
@RestController  
@RequestMapping("/article")  
public class ArticleController {  
    @GetMapping("/list")  
    public Result<String> list() {  
        return Result.success("所有的文章数据...");  
    }  
}
```

那么当我们登录http://localhost:8080/article/list时，会发现：
```json
code: 0
message: "操作成功"
data: "所有的文章数据..."
```
没有登录，竟然把所有文章显示了出来。所以我们要添加登录验证功能，使得登录后才可以显示所有文章。

**解决方案：** 需要我们登录时生成一个令牌，从而避免这个问题。
经过（3）的JWT令牌认证后，我们通过postman进行测试时，输入正确的Token，就会：
```json
{
    "code": 0,
    "message": "操作成功",
    "data": "所有的文章数据..."
}
```

错误的情况下就会：
```json
{
    "code": 1,
    "message": "未登录",
    "data": null
}
```

我们也可以把认证的事情放在WebConfig类：
```java
package com.itheima.config;  
  
import com.itheima.interceptors.LoginInterceptor;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.context.annotation.Configuration;  
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;  
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;  
  
@Configuration  
public class WebConfig implements WebMvcConfigurer {  
    @Autowired  
    private LoginInterceptor loginInterceptor;  
  
    @Override  
    public void addInterceptors(InterceptorRegistry registry) {  
        //登录接口和注册接口不拦截  
        registry.addInterceptor(loginInterceptor).excludePathPatterns("/user/login", "/user/register");  
    }  
}
```
## 4）获取用户详细信息
### （1）主逻辑
```java
@GetMapping("/userInfo")  
public Result<User> userInfo(@RequestHeader(name = "Authorization") String token) {  
    //根据用户名查询用户  
    Map<String, Object> map = JwtUtil.parseToken(token);  
    String username = (String) map.get("username");  
  
    User user = UserService.findByUserName(username);  
    return Result.success(user);  
}
```

在postman的用户相关接口---Pre-request中添加下列代码：
```script
pm.request.addHeader("Authorization:eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGFpbXMiOnsiaWQiOjgsInVzZXJuYW1lIjoiMTIzNDU2NyJ9LCJleHAiOjE3NTMxNDEyNzh9.Zmqk5bVdTeTyFGru40S8zEYjm5_73uXSRnNjDDs3X3k");
```

屏蔽显示密码：
```java
import com.fasterxml.jackson.annotation.JsonIgnore;

@JsonIgnore   //让springmvc把当前对象转换成json字符串的时候，忽略password，最终的json字符串中就没有password这个属性
```

最终json：
```json
{
    "code": 0,
    "message": "操作成功",
    "data": {
        "id": 8,
        "username": "1234567",
        "nickname": "",
        "email": "",
        "userPic": "",
        "createTime": "2025-07-20T11:40:28",
        "updateTime": "2025-07-20T11:40:28"
    }
}
```
### （2）ThreadLocal优化代码
提供线程局部变量
- 用来存取数据：set()/get()
- 使用ThreadLocal存储的数据，线程安全
演示代码：
```java
@Test  
public void testThreadLocal() {  
    //提供一个ThreadLocal对象  
    ThreadLocal tl = new ThreadLocal();  
  
    //开启两个线程  
    new Thread(() -> {  
        tl.set("晓燕");  
        System.out.println(Thread.currentThread().getName() + ": " + tl.get());  
        System.out.println(Thread.currentThread().getName() + ": " + tl.get());  
        System.out.println(Thread.currentThread().getName() + ": " + tl.get());  
    },"蓝色").start();  
  
    new Thread(() -> {  
        tl.set("姚晨");  
        System.out.println(Thread.currentThread().getName() + ": " + tl.get());  
        System.out.println(Thread.currentThread().getName() + ": " + tl.get());  
        System.out.println(Thread.currentThread().getName() + ": " + tl.get());  
    },"绿色").start();  
}
```

输出：
```shell
绿色: 姚晨
蓝色: 晓燕
绿色: 姚晨
绿色: 姚晨
蓝色: 晓燕
蓝色: 晓燕
```
## 5）更新用户的基本信息
### （1）主要逻辑
在UserController中新增：
```java
@PutMapping("/update")  
public Result update(@RequestBody User user) {  
    UserService.update(user);  
    return Result.success();  
}
```

Userservice里面先声明方法：
```java
//更新  
void update(User user);
```

impl里面实现方法：
```java
@Override  
public void update(User user) {  
    user.setUpdateTime(LocalDateTime.now());  
    UserMapper.update(user);  
}
```

UserMapper里面操作数据库：
```java
//更新用户信息  
@Update("update user set nickname=#{nickname},email=#{email},update_time=#{updateTime} where id=#{id}")  
void update(User user);
```
### （2）参数校验
在User实体类里进行如下修正：
```java
public class User {  
    @NotNull  
    private Integer id;//主键ID  
  
    private String username;//用户名  
    @JsonIgnore   //让springmvc把当前对象转换成json字符串的时候，忽略password，最终的json字符串中就没有password这个属性  
    private String password;//密码  
  
    @Pattern(regexp = "^\\S{1,10}$")  
    private String nickname;//昵称  
  
    @NotEmpty  
    @Email    private String email;//邮箱  
    private String userPic;//用户头像地址  
    private LocalDateTime createTime;//创建时间  
    private LocalDateTime updateTime;//更新时间  
}
```
即可进行参数校验。
## 6）更新用户头像
在UserController中新增：
```java
@PatchMapping("/updateAvatar")  
public Result updateAvatar(@RequestParam String avatarUrl) {  
    UserService.updateAvatar(avatarUrl);  
    return Result.success();  
}
```

Userservice里面先声明方法：
```java
//更新头像  
void updateAvatar(String url);
```

impl里面实现方法：
```java
@Override  
public void updateAvatar(String avatarUrl) {  
    Map<String, Object> map = ThreadLocalUtil.get();  
    Integer id = (Integer) map.get("id");  
    UserMapper.updateAvatar(avatarUrl, id);  
}
```

UserMapper里面操作数据库：
```java
//更新用户头像  
@Update("update user set user_pic=#{avatarUrl},update_time=now() where id=#{id}")  
void updateAvatar(String avatarUrl, Integer id);
```
## 7）更新用户密码
在UserController中新增：
```java
@PatchMapping("/updatePwd")  
public Result updatePwd(@RequestBody Map<String, String> params) {  
    //1. 校验参数  
    String oldPwd = params.get("old_pwd");  
    String newPwd = params.get("new_pwd");  
    String rePwd = params.get("re_pwd");  
  
    if(!StringUtils.hasLength(oldPwd) || !StringUtils.hasLength(newPwd) || !StringUtils.hasLength(rePwd)) {  
        return Result.error("密码不能为空！");  
    }  
    Map<String, Object> map = ThreadLocalUtil.get();  
    String username = (String) map.get("username");  
    User loginUser = UserService.findByUserName(username);  
    if (!loginUser.getPassword().equals(Md5Util.getMD5String(oldPwd))) {  
        return Result.error("原密码填写不正确！");  
    }  
    //newPwd和rePwd是否一样  
    if(!rePwd.equals(newPwd)) {  
        return Result.error("两次填写的新密码不一样");  
    }  
    //2.调用service完成密码更新  
    UserService.updatePwd(newPwd);  
    return Result.success();  
}
```

Userservice里面先声明方法：
```java
//更新用户密码  
void updatePwd(String md5String);
```

impl里面实现方法：
```java
@Override  
public void updatePwd(String newPwd) {  
    Map<String, Object> map = ThreadLocalUtil.get();  
    Integer id = (Integer) map.get("id");  
    UserMapper.updatePwd(Md5Util.getMD5String(newPwd), id);  
}
```

UserMapper里面操作数据库：
```java
//更新用户密码  
@Update("update user set password=#{md5String},update_time=now() where id=#{id}")  
void updatePwd(String md5String, Integer id);
```
即可完成修改密码功能。
# 四、文章分类相关功能
## 1）新增文章分类
添加CategoryController类、CategoryMapper接口、CategoryService接口、CategoryServiceimpl类。
CategoryController类：
```java
package com.itheima.controller;  
  
import com.itheima.pojo.Category;  
import com.itheima.pojo.Result;  
import com.itheima.service.CategoryService;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.validation.annotation.Validated;  
import org.springframework.web.bind.annotation.PostMapping;  
import org.springframework.web.bind.annotation.RequestBody;  
import org.springframework.web.bind.annotation.RequestMapping;  
import org.springframework.web.bind.annotation.RestController;  
  
@RestController  
@RequestMapping("/category")  
public class CategoryController {  
    @Autowired  
    private CategoryService categoryService;  
  
    @PostMapping  
    public Result add(@RequestBody @Validated Category category) {  
        categoryService.add(category);  
        return Result.success();  
    }  
}
```

CategoryMapper接口：
```java
package com.itheima.mapper;  
  
import com.itheima.pojo.Category;  
import org.apache.ibatis.annotations.Insert;  
import org.apache.ibatis.annotations.Mapper;  
import org.apache.ibatis.annotations.Update;  
  
@Mapper  
public interface CategoryMapper {  
    //新增文章分类  
    @Insert("insert into category(category_name,category_alias,create_user,create_time,update_time)" +  
                "values(#{categoryName},#{categoryAlias},#{createUser},#{createTime},#{updateTime})")  
    void add(Category category);  
}
```

CategoryService接口：
```java
package com.itheima.service;  
  
import com.itheima.pojo.Category;  
  
public interface CategoryService {  
    //新增分类  
    void add(Category category);  
  
}
```

CategoryServiceimpl类：
```java
package com.itheima.service.impl;  
  
import com.itheima.mapper.CategoryMapper;  
import com.itheima.pojo.Category;  
import com.itheima.service.CategoryService;  
import com.itheima.utils.ThreadLocalUtil;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.stereotype.Service;  
  
import java.time.LocalDateTime;  
import java.util.Map;  
  
@Service  
public class CategoryServiceimpl implements CategoryService {  
    @Autowired  
    private CategoryMapper categoryMapper;  
  
    @Override  
    public void add(Category category) {  
        //补充属性值  
        category.setCreateTime(LocalDateTime.now());  
        category.setUpdateTime(LocalDateTime.now());  
        Map<String,Object> map = ThreadLocalUtil.get();  
        Integer userId =(Integer) map.get("id");  
  
        category.setCreateUser(userId);  
        categoryMapper.add(category);  
    }  
}
```

同时，我们要在Category实体类中添加参数校验：
```java
package com.itheima.pojo;  
  
import jakarta.validation.constraints.NotEmpty;  
import jakarta.validation.constraints.NotNull;  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
import java.time.LocalDateTime;  
  
@Data  
@AllArgsConstructor  
@NoArgsConstructor  
public class Category {  
    private Integer id;//主键ID  
    @NotEmpty  
    private String categoryName;//分类名称  
    @NotEmpty  
    private String categoryAlias;//分类别名  
    private Integer createUser;//创建人ID  
    private LocalDateTime createTime;//创建时间  
    private LocalDateTime updateTime;//更新时间  
}
```
## 2）获取文章分类列表
CategoryController类：
```java
@GetMapping  
public Result<List<Category>> list() {  
    List<Category> cs = categoryService.list();  
    return Result.success(cs);  
}
```

CategoryMapper接口：
```java
//查询所有文章分类  
@Select("select * from category where create_user=#{userId}")  
List<Category> list(Integer userId);
```

CategoryService接口：
```java
//获取分类列表  
List<Category> list();
```

CategoryServiceimpl类：
```java
@Override  
public List<Category> list() {  
    Map<String,Object> map = ThreadLocalUtil.get();  
    Integer userId =(Integer) map.get("id");  
    return categoryMapper.list(userId);  
}
```
## 3）获取文章分类详情
CategoryController类：
```java
@GetMapping("/detail")  
public Result<Category> detail(Integer id) {  
    Category c = categoryService.findById(id);  
    return Result.success(c);  
}
```

CategoryMapper接口：
```java
//获取文章分类详情  
@Select("select * from category where id=#{id}")  
Category findById(Integer id);
```

CategoryService接口：
```java
//获取文章分类详情  
public Category findById(Integer id);
```

CategoryServiceimpl类：
```java
@Override  
public List<Category> list() {  
    Map<String,Object> map = ThreadLocalUtil.get();  
    Integer userId =(Integer) map.get("id");  
    return categoryMapper.list(userId);  
}
```
返回文章分类的详情。
## 4）更新文章分类
### （1）主逻辑
CategoryController类：
```java
@GetMapping("/detail")  
public Result<Category> detail(Integer id) {  
    Category c = categoryService.findById(id);  
    return Result.success(c);  
}
```

CategoryMapper接口：
```java
//获取文章分类详情  
@Select("select * from category where id=#{id}")  
Category findById(Integer id);
```

CategoryService接口：
```java
//获取文章分类详情  
public Category findById(Integer id);
```

CategoryServiceimpl类：
```java
@Override  
public List<Category> list() {  
    Map<String,Object> map = ThreadLocalUtil.get();  
    Integer userId =(Integer) map.get("id");  
    return categoryMapper.list(userId);  
}
```
### （2）分组校验
把校验项进行归类分组，在完成不同的功能的时候，校验指定组中的校验项
1. 定义分组
2. 定义校验项时指定归属的分组
3. 校验时指定要校验的分组
在Category实体类中如此操作：
```java
@NotNull(groups = Update.class)  
private Integer id;//主键ID  
@NotEmpty(groups = {Add.class, Update.class})  
private String categoryName;//分类名称  
@NotEmpty(groups = {Add.class, Update.class})
public interface Add {}  
public interface Update {}
```
在Controller类中添加接口：
```java
@PostMapping  
public Result add(@RequestBody @Validated(Category.Add.class) Category category) {  
    categoryService.add(category);  
    return Result.success();  
}
@PutMapping()  
public Result<Category> update(@RequestBody @Validated(Category.Update.class) Category category) {  
    categoryService.update(category);  
    return Result.success();  
}
```
## 5）删除文章
CategoryController类：
```java
@DeleteMapping()  
public Result<Category> delete(Integer id) {  
    categoryService.delete(id);  
    return Result.success();  
}
```

CategoryMapper接口：
```java
//删除文章分类  
@Delete("delete from category where id=#{id}")  
void delete(Integer id);
```

CategoryService接口：
```java
//删除文章分类  
void delete(Integer id);
```

CategoryServiceimpl类：
```java
@Override  
public void delete(Integer id) {  
    categoryMapper.delete(id);  
}
```
# 五、文章相关
